import sys

# BOJ 4949 - 균형잡힌 세상 (for 유나)
# 꼼꼼히 다시 읽어봤어용!
# 이번 코드는 유나씨가 보내주신 코드 흐름을 토대로,
# 문제를 처음부터 다시 읽어보며 어떤 부분에서 차이가 생기는지 하나씩 확인한 뒤 정리했습니다.
#
# 유나씨 코드가 전반적으로 방향은 정말 정확했어요.
# 다만 4949는 괄호의 '개수'가 아니라 '열리고 닫히는 순서'가 핵심이라,
# 입력 처리 방식이나 조건 분기 순서에서 아주 작은 차이도 결과에 영향을 줍니다.
#
# 특히 문자열의 마지막 문자를 잘라내는 부분(str[:-1]), 
# 그리고 if/if/if 형태로 분기되는 구조 때문에
# 스택의 pop 이후에도 다음 조건이 계속 평가되는 문제가 생길 수 있었어요.
#
# 그래서 여기서는
# - 입력 줄 자체는 그대로 사용하고
# - 종료 조건만 "." 줄로 명확히 분리하고
# - if / elif 구조로 흐름을 안정화시키는 방식으로 다시 정리해봤습니다.
#
# 유나씨 코드와 거의 동일한 로직이지만,
# 미묘한 부분들을 정리해 넣은 버전같은 것 이라고 생각해주시면 좋을 것 같아요.


for line in sys.stdin:
    line = line.rstrip('\n')

    # 문제에서 "."은 입력의 종료를 의미.
    # 유나씨처럼 문자열 끝을 잘라내는 방식도 가능하지만,
    # 이렇게 '종료 줄만 따로 처리'하는 게 구조적으로 조금 더 안전하더라고요.
    if line == '.':
        break

    stack = []          # 열린 괄호를 쌓아서 마지막 열린 괄호를 바로 확인할 수 있도록 함
    is_balanced = True  # 중간에 짝이 틀리는 순간 False로 전환

    for ch in line:

        # 여는 괄호는 그대로 스택에 쌓음
        if ch == '(' or ch == '[':
            stack.append(ch)

        # 닫는 괄호가 나오면 스택 top과 짝을 비교해야 함
        elif ch == ')':
            # 스택이 비어 있거나 '('이 아니라면 순서가 이미 깨진 것
            # 유나씨 코드도 이 부분 의도가 정확했는데,
            # if / if / if 구조 때문에 pop 후 다음 if도 평가되는 문제가 있었어요.
            if not stack or stack[-1] != '(':
                is_balanced = False
                break
            stack.pop()

        elif ch == ']':
            if not stack or stack[-1] != '[':
                is_balanced = False
                break
            stack.pop()

        # 문자는 괄호가 아니면 균형 판별에 영향 없음
        else:
            continue

    # 문자열을 모두 확인한 뒤,
    # is_balanced가 한 번도 깨지지 않았고,
    # 스택이 비어 있어야 모든 괄호가 올바르게 닫힌 것.
    #
    # 유나씨 코드에서도 마지막에 스택 길이를 체크하셨는데,
    # 문자열 끝을 잘라내는 부분 때문에 괄호가 하나씩 누락되는 상황이 있었던 것 같아요.
    if is_balanced and not stack:
        print("yes")
    else:
        print("no")

        from collections import deque

n = int(input())
q = deque(range(1, n+1))

while len(q) > 1:
    q.popleft()          # 버리고
    q.append(q.popleft())  # 뒤로 보내고

print(q[0])

import sys
input = sys.stdin.readline


T = int(input())  # 테스트 케이스 개수


for _ in range(T):
    s = input().rstrip()

    # ---------------------- 문제 이해 & 접근 이유 ----------------------
    # 목표: 주어진 문자열이 '올바른 괄호 문자열(VPS)'인지 판별해야 한다.
    #
    # 올바른 괄호의 조건은 다음 두 가지가 핵심이다.
    #  1) ')'가 등장했을 때, 이전에 매칭 가능한 '('가 반드시 존재해야 한다.
    #  2) 문자열이 끝났을 때 '('가 남아 있으면 안 된다.
    #
    # 즉, 실시간으로 "짝을 맞출 수 있는 상태인지" 확인해야만 한다.
    #
    # → 이 문제는 LIFO 구조(마지막에 넣은 '('를 먼저 처리)로 동작하므로
    #    스택을 쓰는 것이 구조적으로 최적이다.
    #
    # 다른 방법을 고민해본 결과:
    #   - 카운트로만 확인하면 "())(" 같은 케이스 처리가 불가능.
    #   - deque를 써도 되지만 스택 목적이라면 list가 더 빠르고 단순.
    #   - 정규식이나 replace 기반 접근은 비효율 + 불안정.
    #
    # 결론 → "list 기반 스택"이 가장 빠르고 안정적인 최선의 접근.

    stack = []
    is_vps = True  # 일단 YES라 가정하고, 예외 상황에서 False로 바꾼다.


    # ---------------------- 시뮬레이션 진행 ----------------------
    for ch in s:
        if ch == '(':
            # 여는 괄호는 나중에 닫힐 수 있으므로 스택에 쌓아둔다.
            stack.append(ch)
        else:  # ch == ')'
            # 닫는 괄호가 나왔는데 스택이 비어있다면 매칭 불가능 → 즉시 NO
            if not stack:
                is_vps = False
                break
            # 정상 매칭 → 스택에서 '(' 하나 제거
            stack.pop()


    # ---------------------- 문자열 종료 후 최종 체크 ----------------------
    # 스택에 '('가 남아있으면 닫히지 않은 괄호가 있다는 것 → NO
    if stack:
        is_vps = False

    print("YES" if is_vps else "NO")
