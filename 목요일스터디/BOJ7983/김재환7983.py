# BOJ 7983 - 내일 할거야
#
# 문제 요약:
#   과제 N개가 있다.
#   각 과제는
#     - d일 동안 연속으로 해야 하고 (쪼갤 수 없음)
#     - t일까지 끝내야 한다.
#   하루에 하나의 과제만 할 수 있다.
#
# 질문:
#   "내일부터" 연속으로 최대 며칠을 쉴 수 있는가?
#
# --------------------------------------------------
# 사고를 전환해볼ㄹㄹ까
#
# 1) '쉬는 날'을 직접 세려고 하면 복잡하다.
# 2) 대신 이렇게 바꿔 생각한다.
#
#    쉬는 날을 최대화
#    = 첫 번째 과제를 시작하는 날짜를 최대화
#
#    첫 과제를 S일에 시작하면
#    1일 ~ (S-1)일까지는 전부 쉰다.
#
#    따라서 우리가 구해야 할 것은:
#    "모든 과제를 제약 안에서 끝낼 수 있는
#     가장 늦은 첫 시작 날짜"
#
# --------------------------------------------------
# 그리디 전략
#
#  과제들을 최대한 "뒤로" 미루고 싶다.
#
# 
#   - 과제들을 마감일에 최대한 붙여서 배치한다.
#
#
#   - 어떤 과제를 더 일찍 시작할 이유는 없다.
#   - 마감일만 지킨다면, 늦게 시작할수록 이득이다.
#
# 따라서:
#   1) 과제들을 마감일 기준으로 정렬
#   2) 가장 마감이 늦은 과제부터
#   3) 가능한 한 "뒤에서부터" 차례대로 붙인다.
#
# 이 전략은
#   - 마감일을 어기지 않으면서
#   - 첫 과제 시작일을 최대화한다.
#
# --------------------------------------------------

import sys
input = sys.stdin.readline

n = int(input())
jobs = []

# 입력 처리
# (t, d) 형태로 저장한다.
# 이유:
#   - 마감일 t 기준 정렬을 쉽게 하기 위해
for _ in range(n):
    d, t = map(int, input().split())
    jobs.append((t, d))

# 마감일 오름차순 정렬
# 예: t가 작은 과제일수록 앞에 온다.
jobs.sort()

# time의 의미:
#   지금까지 배치한 과제들보다
#   "앞쪽에" 새 과제를 붙일 수 있는
#   가장 늦은 종료 시점
#
# 아직 아무 과제도 배치하지 않았으므로
# 처음에는 충분히 큰 값으로 시작
time = 10**18

# 뒤에서부터 과제를 배치한다.
# (마감일이 가장 늦은 과제부터)
for t, d in reversed(jobs):

    # 이 과제는 t일까지 끝나야 한다.
    # 그런데 이미 뒤쪽 과제들이 있어서
    # 그보다 늦게 끝낼 수는 없다.
    #
    # 따라서 실제로 가능한 종료 시점은
    #   min(현재 time, 이 과제의 마감일 t)
    time = min(time, t)

    # 과제는 d일 동안 연속으로 해야 하므로
    # 시작 시점은 (종료 시점 - d)
    time -= d

# 모든 과제를 배치하고 나면
# time은 "첫 번째 과제의 시작 날짜"가 된다.
#
# 문제에서 요구하는 것은:
#   내일부터 연속으로 쉴 수 있는 최대 일수
#
# 이 문제에서는
#   '첫 과제 시작일 = 정답'
# 이 된다.
#
# (이 부분이 헷갈리기 쉬운 포인트였고,
#  여기서 -1을 하면 오답이 난다.)
print(time)
